# Phase 1.5 – QA, Packaging & Docs

## Highlights
- **Release tooling** – `lorch release` cross-compiles darwin/linux binaries (amd64 + arm64), writes `dist/manifest.json`, and runs architecture-aware smoke checks.
- **Test harness refresh** – `pkg/testharness` gained binary builders, reusable smoke scenarios (including review/spec change-request loops), and an end-to-end test that drives mock agents via fixtures.
- **CI automation** – GitHub Actions pipeline runs lint → unit tests → smoke tests, archiving logs under `logs/ci/<run-id>/` and uploading them as artifacts.
- **Static analysis** – `golangci-lint` adopted with a focused ruleset (govet, staticcheck, gosimple, ineffassign, errcheck, gofmt).
- **Documentation** – README quick start, `docs/AGENT-SHIMS.md`, and these release notes capture the Phase 1.5 surface area.

## Binaries
- `dist/<os>-<arch>/lorch` – statically linked executables for darwin/linux (arm64 & amd64).
- `dist/manifest.json` – build metadata (Go version, git commit), artefact checksums, smoke status per target.

Generate them locally:
```bash
go run ./cmd/lorch release
# or limit targets
go run ./cmd/lorch release --target $(go env GOOS)/$(go env GOARCH)
```

## Quality Gates
- `golangci-lint run`
- `go test ./...`
- `go test ./pkg/testharness -run TestRunSmoke -v`

CI mirrors the same commands and stores transcripts in `logs/ci/${{ github.run_id }}/`.

## Follow-ups
- Extend smoke fixtures to cover builder failure paths and orchestration/NL-intake flows as Phase 2 lands.
- Wire native NL-intake scenarios into the harness during Phase 2.
