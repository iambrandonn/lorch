package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"time"
)

// LLMConfig holds configuration for LLM CLI calls
type LLMConfig struct {
	CLIPath        string
	Timeout        time.Duration
	MaxOutputBytes int64
}

// DefaultLLMConfig returns sensible defaults for LLM configuration
func DefaultLLMConfig(cliPath string) LLMConfig {
	return LLMConfig{
		CLIPath:        cliPath,
		Timeout:        180 * time.Second,
		MaxOutputBytes: 1024 * 1024, // 1MB
	}
}

// RealLLMCaller implements LLMCaller using external CLI processes
type RealLLMCaller struct {
	config LLMConfig
}

// NewRealLLMCaller creates a new real LLM caller
func NewRealLLMCaller(config LLMConfig) *RealLLMCaller {
	return &RealLLMCaller{
		config: config,
	}
}

// Call executes the LLM CLI with the given prompt
func (r *RealLLMCaller) Call(ctx context.Context, prompt string) (string, error) {
	// Create command with timeout
	cmdCtx, cancel := context.WithTimeout(ctx, r.config.Timeout)
	defer cancel()

	// Create the command
	cmd := exec.CommandContext(cmdCtx, r.config.CLIPath)

	// Set up pipes
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return "", fmt.Errorf("failed to create stdin pipe: %w", err)
	}
	defer stdin.Close()

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return "", fmt.Errorf("failed to create stdout pipe: %w", err)
	}
	defer stdout.Close()

	stderr, err := cmd.StderrPipe()
	if err != nil {
		return "", fmt.Errorf("failed to create stderr pipe: %w", err)
	}
	defer stderr.Close()

	// Start the process
	if err := cmd.Start(); err != nil {
		return "", fmt.Errorf("failed to start LLM CLI: %w", err)
	}

	// Write prompt to stdin in a goroutine
	writeDone := make(chan error, 1)
	go func() {
		defer stdin.Close()
		_, err := io.WriteString(stdin, prompt)
		writeDone <- err
	}()

	// Read stdout with size limit
	var output bytes.Buffer
	limitedReader := io.LimitReader(stdout, r.config.MaxOutputBytes)
	readDone := make(chan error, 1)
	go func() {
		_, err := io.Copy(&output, limitedReader)
		readDone <- err
	}()

	// Capture stderr for diagnostics (non-blocking)
	var stderrBuf bytes.Buffer
	go func() {
		io.Copy(&stderrBuf, stderr)
	}()

	// Wait for stdin write to complete
	if err := <-writeDone; err != nil {
		cmd.Process.Kill()
		cmd.Wait()
		return "", fmt.Errorf("failed to write prompt to stdin: %w", err)
	}

	// Wait for stdout read to complete
	if err := <-readDone; err != nil {
		cmd.Process.Kill()
		cmd.Wait()
		return "", fmt.Errorf("failed to read LLM output: %w", err)
	}

	// Wait for the process to complete
	if err := cmd.Wait(); err != nil {
		// Log stderr for diagnostics (but don't fail on stderr content)
		if stderrBuf.Len() > 0 {
			fmt.Fprintf(os.Stderr, "LLM CLI stderr: %s\n", stderrBuf.String())
		}
		return "", fmt.Errorf("LLM CLI failed: %w", err)
	}

	// Check if we hit the size limit
	if output.Len() >= int(r.config.MaxOutputBytes) {
		return "", fmt.Errorf("LLM output exceeds size limit of %d bytes", r.config.MaxOutputBytes)
	}

	// Log stderr for diagnostics if present
	if stderrBuf.Len() > 0 {
		fmt.Fprintf(os.Stderr, "LLM CLI stderr: %s\n", stderrBuf.String())
	}

	return output.String(), nil
}

// MockLLMCaller implements LLMCaller for testing
type MockLLMCaller struct {
	responses map[string]string
	errors    map[string]error
	callCount int
}

// NewMockLLMCaller creates a new mock LLM caller
func NewMockLLMCaller() *MockLLMCaller {
	return &MockLLMCaller{
		responses: make(map[string]string),
		errors:    make(map[string]error),
		callCount: 0,
	}
}

// SetResponse sets a mock response for a given prompt
func (m *MockLLMCaller) SetResponse(prompt, response string) {
	m.responses[prompt] = response
}

// SetError sets a mock error for a given prompt
func (m *MockLLMCaller) SetError(prompt string, err error) {
	m.errors[prompt] = err
}

// CallCount returns the number of times Call has been invoked
func (m *MockLLMCaller) CallCount() int {
	return m.callCount
}

// Call returns the mock response for the given prompt
func (m *MockLLMCaller) Call(ctx context.Context, prompt string) (string, error) {
	m.callCount++

	// Check for exact error match first
	if err, exists := m.errors[prompt]; exists {
		return "", err
	}

	// Check for wildcard error
	if err, exists := m.errors[""]; exists {
		return "", err
	}

	// Check for exact response match
	if response, exists := m.responses[prompt]; exists {
		return response, nil
	}

	// Check for empty string key (wildcard)
	if response, exists := m.responses[""]; exists {
		return response, nil
	}

	// Default mock response
	return `{
		"plan_file": "PLAN.md",
		"confidence": 0.95,
		"tasks": [
			{
				"id": "T-001",
				"title": "Mock task",
				"files": ["test.go"],
				"notes": "Generated by mock LLM"
			}
		],
		"needs_clarification": false,
		"clarification_questions": []
	}`, nil
}
