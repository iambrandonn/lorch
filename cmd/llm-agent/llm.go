package main

import (
	"context"
	"fmt"
	"os/exec"
	"time"
)

// LLMConfig holds configuration for LLM CLI calls
type LLMConfig struct {
	CLIPath        string
	Timeout        time.Duration
	MaxOutputBytes int64
}

// DefaultLLMConfig returns sensible defaults for LLM configuration
func DefaultLLMConfig(cliPath string) LLMConfig {
	return LLMConfig{
		CLIPath:        cliPath,
		Timeout:        180 * time.Second,
		MaxOutputBytes: 1024 * 1024, // 1MB
	}
}

// RealLLMCaller implements LLMCaller using external CLI processes
type RealLLMCaller struct {
	config LLMConfig
}

// NewRealLLMCaller creates a new real LLM caller
func NewRealLLMCaller(config LLMConfig) *RealLLMCaller {
	return &RealLLMCaller{
		config: config,
	}
}

// Call executes the LLM CLI with the given prompt
func (r *RealLLMCaller) Call(ctx context.Context, prompt string) (string, error) {
	// Create command with timeout
	cmdCtx, cancel := context.WithTimeout(ctx, r.config.Timeout)
	defer cancel()

	_ = exec.CommandContext(cmdCtx, r.config.CLIPath) // TODO: Implement full subprocess management

	// TODO: Implement full subprocess management
	// - Set up stdin/stdout pipes
	// - Write prompt to stdin
	// - Read response from stdout with size limits
	// - Handle stderr for diagnostics
	// - Wait for completion

	// Stub implementation
	return fmt.Sprintf("LLM response to: %s", prompt), nil
}

// MockLLMCaller implements LLMCaller for testing
type MockLLMCaller struct {
	responses map[string]string
	callCount int
}

// NewMockLLMCaller creates a new mock LLM caller
func NewMockLLMCaller() *MockLLMCaller {
	return &MockLLMCaller{
		responses: make(map[string]string),
		callCount: 0,
	}
}

// SetResponse sets a mock response for a given prompt
func (m *MockLLMCaller) SetResponse(prompt, response string) {
	m.responses[prompt] = response
}

// CallCount returns the number of times Call has been invoked
func (m *MockLLMCaller) CallCount() int {
	return m.callCount
}

// Call returns the mock response for the given prompt
func (m *MockLLMCaller) Call(ctx context.Context, prompt string) (string, error) {
	m.callCount++

	if response, exists := m.responses[prompt]; exists {
		return response, nil
	}

	// Default mock response
	return `{
		"plan_file": "PLAN.md",
		"confidence": 0.95,
		"tasks": [
			{
				"id": "T-001",
				"title": "Mock task",
				"files": ["test.go"],
				"notes": "Generated by mock LLM"
			}
		],
		"needs_clarification": false,
		"clarification_questions": []
	}`, nil
}
